;; .. -*- mode: scheme -*-
;;
;; Lunula - A portable Lisp
;;
;; Copyright (c) Anthony Fairchild
;;
;; This software is subject to the Microsoft Public License
;; (Ms-PL). See LICENSE.txt for details.
;;

(define (read-char port)
  (@read-char port))

(define (peek-char port . args)
  (let ((skip (arg-ref args 0 0)))
    (@peek-char-skip port skip)))

(define (read-from-string str)
  (read (open-input-string str)))

(define (eof-object? thing) 
  (@eof-object? thing))

(define (read-tokens port)
  (let ((ch (@peek-char port)))
    (cond ((or (eof-object? ch)
               (char-whitespace? ch)
               (char-quote? ch)
               (char-quasiquote? ch)
               (char-comma? ch)
               (char-dbl-quote? ch)
               (char-open-paren? ch)
               (char-close-paren? ch)
               (char-comment? ch)) 
           '())
          ((char-backslash? ch) 
           (read-char port) 
           (cons (read-char port) 
                 (read-tokens port)))
          (else (cons (read-char port) 
                      (read-tokens port))))))

(define (read-symbol-or-number port)
  (let* ((str (list->string (read-tokens port)))
         (num (string->number str)))
    (if num num (string->symbol str))))

(define (read-pound port)
  (read-char-verify port #\#)
  (let ((ch (@peek-char port)))
    (cond ((eof-object? ch) (error 'read-pound "unexpected eof while reading character"))
          ((char-backslash? ch)
           (let ((tokens (read-tokens port)))
             (cond ((= 1 (list-length tokens)) (car tokens))
                   (else (let ((str (list->string tokens)))
                           (cond ((string=? "tab" str)      #\tab)
                                 ((string=? "space" str)    #\space)
                                 ((string=? "newline" str)  #\newline)
                                 ((string=? "return" str)   #\return)
                                 ((string=? "linefeed" str) #\linefeed)
                                 ((> (list-length tokens) 1)     (error 'read-pound "Invalid character literal ~A" str))
                                 (else (car tokens))))))))
          (else (let ((str (list->string (read-tokens port))))
                  (cond ((string=? "t" str) #t)
                        ((string=? "f" str) #f)
                        (else (error 'read-pound "Invalid literal ~A" ch))))))))

(define (eat-whitespace port)
  (define ch (@peek-char port))
  (when (char-whitespace? ch) 
        (read-char port)
        (eat-whitespace port)))

(define (read-char-verify port desired-ch)
  (let ((ch (read-char port)))
    (unless (char=? ch desired-ch)
            (error 'read-char-verify "Expected ~A but got ~A" ch desired-ch))))

(define (read-list port)
  (define (loop)
    (define ch (@peek-char port))
    (cond ((eof-object? ch) (error 'read-list "unexpected eof while reading list (unmatched paren?)"))
          ((char-whitespace? ch)  (eat-whitespace port)
           (loop))
          ((char-comment? ch)     (read-comment port)
           (loop))
          ((char-close-paren? ch) (read-char-verify port #\))
           '())
          ((char-dot? ch)         (let ((ch (@peek-char-skip port 1)))
                                    (cond ((char-numeric? ch) 
                                           (cons (read port) (loop)))
                                          (else (read-char-verify port #\.)
                                                (let ((b (read port)))    
                                                  (eat-whitespace port)
                                                  (let ((cp (read-char port)))
                                                    (unless (char-close-paren? cp)
                                                            (error 'read-list "expected ) but got ~a" cp)))
                                                  b)))))
          (else                   (cons (read port) (loop)))))
  (read-char-verify port #\()
  (loop))

(define (read-quote port)
  (read-char-verify port #\')
  (cons 'quote (cons (read port) '())))

(define (read-quasiquote port)
  (read-char-verify port #\`)
  (cons 'quasiquote (cons (read port) '())))

(define (read-comma port)
  (read-char-verify port #\,)
  (let ((ch (@peek-char port)))
    (cond ((eof-object? ch) (error 'read-pound "unexpected eof while reading unquote (comma)"))
          ((char-at? ch) (read-char port)
           (cons (string->symbol "unquote-splicing") 
                 (cons (read port) '())))
          (else          (cons (string->symbol "unquote") 
                               (cons (read port) '()))))))

(define (read-comment port)
  (define (eat-until-newline port)
    (define ch (read-char port))
    (unless (or (eof-object? ch)
                (eq? #\newline ch))
            (eat-until-newline port)))
  (eat-until-newline port))

(define (read-quoted-string port)
  (define (read-str)
    (define ch (read-char port))
    (cond ((eof-object? ch) (error 'read-pound "unexpected eof while reading string"))
          ((char-backslash? ch) 
           (let ((ch (read-char port)))
             (cond ((eq? ch #\n) (cons #\newline (read-str)))
                   ((eq? ch #\r) (cons #\return (read-str)))
                   ((eq? ch #\t) (cons #\tab (read-str)))
                   ((eq? ch #\\) (cons #\\ (read-str)))
                   ((eq? ch #\") (cons #\" (read-str)))
                   (else (error 'read-quoted-string "invalid escape character ~A" ch)))))
          ((char-dbl-quote? ch) '())
          (else (cons ch (read-str)))))
  (read-char-verify port #\")
  (list->string (read-str)))

(define (char-backslash? ch)   (eq? ch #\\)) 
(define (char-comment? ch)     (eq? ch #\;))
(define (char-quote? ch)       (eq? ch #\'))
(define (char-quasiquote? ch)  (eq? ch #\`))
(define (char-at? ch)          (eq? ch #\@))
(define (char-comma? ch)       (eq? ch #\,))
(define (char-open-paren? ch)  (eq? ch #\())
(define (char-close-paren? ch) (eq? ch #\)))
(define (char-dbl-quote? ch)   (eq? ch #\"))
(define (char-pound? ch)       (eq? ch #\#))
(define (char-dot? ch)         (eq? ch #\.))
(define (char-whitespace? ch)  (member ch (list #\tab #\space #\newline #\return #\linefeed)))

(define (read . args)
  (let ((port (arg-ref args 0 (current-input-port))))
    (define ch (@peek-char port))
    (cond ((eof-object? ch) ch)
          ((char-open-paren? ch) (read-list port))
          ((char-whitespace? ch) (read-char port) (read port))
          ((char-comment? ch)    (read-comment port) (read port))
          ((char-quote? ch)      (read-quote port))
          ((char-quasiquote? ch) (read-quasiquote port))
          ((char-comma? ch)      (read-comma port))
          ((char-dbl-quote? ch)  (read-quoted-string port))
          ((char-pound? ch)      (read-pound port)) ; #\X
          (else (read-symbol-or-number port)))))

(define (open-file-input-port filename)
  (@open-file-input-port filename))

(define (close-input-port port)
  (@close-input-port port))

(define (read-until-eof in)
  (let ((form (read in)))
    (if (eof-object? form)
        '()
        (cons form (read-until-eof in)))))

(define (read-from-file filename)    
  (let* ((in (open-file-input-port filename))
         (form (read-until-eof in)))      
    (close-input-port in)
    (cons 'begin form)))